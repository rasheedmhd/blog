<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title> ML | Rasheed Starlet</title>
    <link rel="stylesheet" type="text/css" href="../main/styles.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Lexend+Deca&family=Work+Sans:wght@400&display=swap"
      rel="stylesheet"
    />
    <script src="main.js"></script>
  </head>

  <body>
    <div id="wrapper">
      <header id="head">
        <ul>
          <li><a href="../index.html">Home</a></li>
          <li><a href="../main/blog.html">Blog</a></li>
          <li><a href="../main/projects.html">Projects</a></li>
          <li><a href="../main/languages.html">Languages</a></li>
        </ul>
      </header>

      <section id="main">
        <p class="date">
          Written Tue, 4th November, 2022, Published on 11th January, 2023
        </p>

        <h1> I am Learning ML but not Machine Learning </h1>

        <h2> ML - Meta Language </h2>

        <p> Is it crazy how if you search ML on the internet of Youtube you get only videos on Machine Learning. Machine Learning has shadowed
            Meta Language, the Programming Language. You would only have better luck if you search <a href="https://en.wikipedia.org/wiki/Standard_ML">Standard ML</a>, which is a modern dialect of ML.
        </p>
<br>
        <p> 
          So why am I learning an obscure ancient programming language? ML is one the most popular Programming Languages that you have never heard of. No, I am not selling you snake oil, it is not like you would buy with bitcoin anyway.         
        </p>

        <p>
          While studying Crafting Interpreters, in page 65 while talking about the Expression Problem, Bob. said that
          "ML, short for “metalanguage” was created by Robin Milner and friends and forms
          one of the main branches in the great programming language family tree. Its children include SML, Caml, OCaml, Haskell, and F#. 
          Even Scala, Rust, and Swift bear a strong resemblance." 
        </p>

        <p>
          This was the catalyst that led me to start studying ML immediately. 
          That said, I had already wanted to learn OCaml. 
          I am a huge fan of programming languages, there is a whole page in this blog where I have listed the languages that I have learnt
          and the languages that I wish to learn. The to learn list will keep on growing. 
          Worth noting is even though I love languages,I am not interesting in FOMOing to learn the the newest and shiny languages. 
          I love old school languages. 
          Why? If you read a little about Programming Languages, you will realize that at one point we created a particular language 
          that was so full of good ideas that most languages that came after them copied a thing or two.

          In my mind if you study a language that had good ideas that 10 modern languages copied ideas from, it is like learning
          1 and getting 10 free. Not exactly, but you get the idea.
        </p>

        <p> Who wouldn't want to learn a language that had so much novel ideas in language design that over 40 years later, 
          other Programming Language designers are taking ideas from? That is ML. At this point I would probably say I am language
          designer sort of and I could make good use of some ideas. One syntax that I found that I thought was pretty need is how you 
          can use #struct_item_name StructName; to get the value of a struct item, borrowing from Rust terminology but in ML we call them Records.
          <div id="code">
            <pre class=”line-numbers”>
                <code class="language-rust">
          ML
          ------
          val Rust = {
            creator = "Graydon Hoare",
            company = "Mozilla",
            release = 2015,
            quote = "Rust's Raison de'tre is safety"
          };

          #creator Rust;
          (* This is weird and neat to me lol *)

          Rust
          ------
          struct Rust {
            creator: String,
            username: String,
            email: String,
            quote: String,
          }
        
          let language = Rust {
            creator: String::from("Graydon Hoare"),
            company: String::from("Mozilla"),
            release: 2015,
            quote: String::from("Rust's Raison de'tre is safety")
          };

          language.creator;
            </code>
          </pre>
      </div>
      </p>

        <p>
          And that was exactly what Bob added below the quote above "Much like Lisp, it[ML] is one of those languages 
          that is so full of good ideas that language designers today are still rediscovering them over forty years later." 
          Yeah, really this was the real catalyst.
        </p>

        <p>
          When I wanted to learn OCaml, it was because I read somewhere that OCaml was used to write the first Rust Compiler.
          That combined with the fact that it is a functional programming language got me interested enough, to want to learn it. 
          And OCaml, more like Caml, SML are all coming from ML. And you can add Roc, which I am hoping to start contributing to 
          its development soon, Elm, are all coming from ML.
        </p>

        <p> Most Programming Languages we use today stem from a few languages, ML is one of those Languages, another is ALGOL. </p>

        <p> That means, even though you might not have heard of ML or given it a second though, you might just be using ML,
            in your favorite language without knowing, because at some point of the design of that language, its designers 
            decided to go with a language feature that was pioneered by ML.
        </p>

        <h2> So Why is Meta Language ? </h2>

        <p>
          I can't make a better write up to this question than what the wikipedia article has so I will just leave a <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">link.</a>
          But stick around to read why I find it worth reading, this is my just my opinion, wildly based on my curiosity.  
        </p>

        <p>
          "While working on the theorem proving system LCF (short for Logic of Computable Functions), Robin Milner and colleagues in the early 1970s created a language for writing scripts to create proofs. 
          Since LCF was itself a language for representing formulas in an underlying logic, 
          the theorem proving language was called the Meta Language, or ML for short.
  The original ML language soon evolved into a general-purpose programming language. Like
  Lisp, it featured first-class functions and pattern matching, and was expression-oriented and
  garbage-collected. Unlike Lisp, ML was statically typed, and was the first language to implement the Hindley-Milner type system and its associated type inference mechanism." - Programming Language Explorations 
          </p>

        <h2> 1. Learn a Functional Programming Language </h2>

        <p>
          ML is a general-purpose functional programming language. I did a lot of my of first programming in Python. Even though, I started with C, I learnt a very tiny part of C and learnt JavaScript but I wrote a lot of my code in Python which is a multi-paradigm dynamic programming language it was through Python that I learnt OOP - Object Oriented Programming and using Python to build web applications with the Django web framework meant most of my code was Object Oriented. I am a big believer that the programming language you use influences how you think, it influences how you approach problem solving. And following the advice of Peter Norvig from his amazing article <a href="https://www.norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a>, I have always wanted to learn a functional programming language. I know about other functional programming languages like Haskell, Elixir, Erlang and many others. I did learn a little Elixir in 2019. I got to know of Erlang through a friend back in 2016, at the time I didn't know the distinctions in programming languages paradigms like I do today, but I wanted to learn Erlang because my friend said it was hard. I never learnt though. Today Erlang and Elixir are part of the languages that I would love to learn later, just out of curiosity. But for now, my functional programming language journey is starting from ML.
        </p>
        <h2> What did Peter Norvig say? </h2>
        <p> 
          In the early days when I started learning to code, I was obsessed with becoming a great programmer, and I would be asking the internet here and there, how to become one but when I found this article I stopped searching. I hope that even if you don't find this article interesting, you would love Peter's advice linked above. 
        </p>
<hr>
        <p> In one section of the article he said, 
          "Learn at least a half dozen programming languages. 
          Include one language that emphasizes class abstractions (like Java or C++), 
          one that emphasizes functional abstraction (like Lisp or ML or Haskell), 
          one that supports syntactic abstraction (like Lisp), 
          one that supports declarative specifications (like Prolog or C++ templates), 
          and one that emphasizes parallelism (like Clojure or Go)."
        </p>
        <hr>
        <br>


        <h2>2. The Hindley-Milner type system </h2>
        <p>
          ML is the first programming language to implement the Hindley-Milner type system, Which is known for its ability to infer the most general types of a program without the programming needing to explicitly type. Think of all the programming languages that have types inference today. I want to explore and learn more of how all those came about. Rust was my first statically typed programming language and I have fallen in love with statically typed programming languages and by extension the theory of type systems and they practicality in programming.  
        </p>

        <!-- <h2> Type Inference </h2>

        <h1> What Rust borrowed from ML </h1>
        <h2> Vectors </h2>
        <h2> Unity - Unit () </h2>

        <h2> Rust Lifetimes and ML any Types</h2> -->

        <p> While I was learning I hit this error message and I couldn't help but notice how similar the syntax looks to Rust Lifetimes.</p>
        <div id="code">
          <pre class=”line-numbers”>
              <code class="language-rust">
          {born: int, crowned: 'a, died: int, name: 'b, quote: 'c} -> int
          Here, 'a, 'b, and 'c are type variables that can be any type, 
          since they are not used in any operations within the function. 
          The fields born and died must be of type int because they are 
          used in the subtraction operation.
              </code>
            </pre>
        </div>
        <br>

        <h2>3. Learn 1 get 10 free. </h2>
        <p> Remember when I said ML is the Most Popular Programming Language you have never heard of? Well take a look at some of the languages that ML influenced.</p>
        <div>
          <ol>

          </ol>
          <li>1. F* </li>
          <li>2. Haskell </li>
          <li>3. Idris </li>
          <li>4. Kotlin </li>
          <li>5. Miranda </li>
          <li>6. Nemerle </li>
          <li>7. OCaml </li>
          <li>8. Opa </li>
          <li>9. Erlang </li>
          <li>10. Rust </li>
          <li>11. Scala </li>
          <li>12. Standard ML</li>
          <li>13. Clojure </li>
          <li>14. Coq </li>
          <li>15. Cyclone</li> 
          <li>16. C+,</li> 
          <li>17. El, </li>
          <li>18. F#</li>
          </ol> 
        </div>

        <!-- <p> Is that Rust has many left and right assoc function? The
          directive infix causes association to the left, while infixr causes association to the right.</p> -->
      </section>
    </div>

    <footer id="foot">
      <p>Made with 💖 by Rasheed Starlet</p>
    </footer>
  </body>
</html>
